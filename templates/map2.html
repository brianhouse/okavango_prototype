<!DOCTYPE html>
<html>
  <head>
    <title>The Digital Bushman: Into the Okavango</title>
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta charset="UTF-8">
    
    <link rel="stylesheet" href="/static/css/leaflet.css" />
    <link rel="stylesheet" href="/static/js/MarkerCluster.css" />
    <link rel="stylesheet" href="/static/js/MarkerCluster.Default.css" />

    <script src="/static/js/leaflet.js"></script>
    <script src="/static/js/leaflet.markercluster.js"></script>
    <script src="/static/js/rcolor.js"></script>
    <script src="/static/js/simplify.js"></script>
	
	<script language="Javascript" type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>

	 <style type="text/css">
		
		iframe { 
			vertical-align: top;
		}
		
		#map_holder{
			position: fixed;
			top: 0px;
			left: 0px;
			width:100%; 
			height:100%;
			z-index: 0;
		}
		
		#map{
			width:100%;
			height:100%; 
			position: "absolute"; 
			top: 0px; 
			left: 0px; 
			overflow: "hidden";
		}

		#holder{
			width: 270px;
			left:50px;
			background: rgba(0,0,0,0.8);
			z-index: 1000;
			position: absolute;
			font: 14px Verdana, Helvetica, sans-serif; 
			color: white;
			padding: 10px;
		}

		#about{
			width: 900px;
			left:50px;
			top:58px;
			background: rgba(0,0,0,0.8);
			z-index: 1000;
			position: absolute;
			font: 14px Verdana, Helvetica, sans-serif; 
			color: white;
			padding: 10px;
		}

		#helppanel{
			width: 900px;
			left:50px;
			top:58px;
			background: rgba(0,0,0,0.8);
			z-index: 1000;
			position: absolute;
			font: 14px Verdana, Helvetica, sans-serif; 
			color: white;
			padding: 10px;
		}

		#skip {
			font: 14px Verdana, Helvetica, sans-serif; 
			
			position: fixed;
			top: 50%;
			left: 50%;
			margin-top: 8px;
			margin-left: -15px;
		}
		
		
		a{
			color: white;
			text-decoration: none;
		}
      }
    </style>
  	
	

  </head>
  <body>

	
	<!--Google Maps APIv3 Background-->
	<div id="map_holder">
		<div id="map"></div>
	</div><!-- End Google Maps Background -->

	<div id="holder">
		<a href="#" id="expedition">About the Expedition</a>
		<a href="#" id="api">Public API</a>
		<a href="#" id="help">Help</a>
	</div>	

	<div id="about">
		<a href="#" id="closeabout">Close this window</a>
		<h2>Digital Bushman : An Live-data Expedition into the Okavango Delta</h2>
		<p>This site displays data which is uploaded daily, via sattelite, by the expedition team in the Okavango delta. Data is also available through a <a href="/api">public API</a>, allowing anyone to re-mix, analyze, or visualize the collected information.</p>
		<p>Here's expedition leader Dr. Steve Boyes, talking about his work in the Okavango:</p>
		<iframe width="420" height="315" src="//www.youtube.com/embed/vAiP1iOv23M" frameborder="0" allowfullscreen></iframe>
		<p><strong><a href="https://en.wikipedia.org/wiki/Okavango_Delta">More information about the Okavango Delta</a></p>
		<p><strong><a href="http://en.wikipedia.org/wiki/Bushmen">More information about the BaYei Bushemn</a></p>
		<a href="http://www.wildbirdtrust.com/"><img src="/static/img/wbtlogo.png" width="401" height="88"></a>
		
	</div>	

	<div id="helppanel">
		<a href="#" id="closehelp">Close this window</a>
		<h2>Need Help?</h2>
		<p>This site is a work in progress - because real expidition data didn't become available until the team in the Delta arrived and started trsnsmitting, we are adding functionality on a daily basis. So check back to watch the expedition progress, and to see and explore new features and new data.</p>
		<p>New data is uploaded once per day, at around 12pm, EST. This data will immediately be available through the <a href="/api">public API</a>, and will be visible on the map at the same time.</p>
		<p>For specific questions, please get in touch - <a href="mailto:okavango@o-c-r.org>">okavango@o-c-r.org</a></p>
	</div>	

	<div id="skip">
		<a href="#">Skip</a>
	</div>


	<script type="text/javascript">

		$("#about").hide();
		$("#helppanel").hide();
	  	// create a map in the "map" div, set the view to a given place and zoom
		var map = L.map('map').setView([-19.2571, 22.6560], 5);
		map.zoomAnimationThreshold = 20;

		// add an OpenStreetMap tile layer
		var satLayer = L.tileLayer('http://a.tiles.mapbox.com/v3/brianhouse.map-oxn5wd2a/{z}/{x}/{y}.png', {
		    attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors', maxZoom: 17
		}).addTo(map);


		// add an OpenStreetMap tile layer
		var flatLayer = L.tileLayer('http://a.tiles.mapbox.com/v3/blprnt.map-vsat7sho/{z}/{x}/{y}.png', {
		    attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors', maxZoom: 17
		})

		//Build some layers
		var beaconLayer = new L.layerGroup().addTo(map);
		var sightingsLayer = new L.layerGroup().addTo(map);
		var geoLayer = new L.layerGroup().addTo(map);
		var commentaryLayer = new L.layerGroup().addTo(map);


		var lastPoint;
		var markers = [];
		var beaconMarkers = [];
		var beaconCoords = [];

		var d = new Date();
		var focusMarker;

		var step = 0;

		var scripts = [
			"This is the Okavango Delta.",
			"Located in Botswana, it is one of the richest wildlife areas on the planet.",
			"On September 7th, a group of BaYei bushmen, scientists and journalists entered the area for an 18-day expedition. The group, led by Dr. Steve Boyes, seeks to explore and survey new parts of the central delta.",
			"On this site, you can follow along in real-time with the expedition, and access all of the data they are collecting, including wildlife sightings, colour samples, and position and heart rate data for individual expedition members.",
			"This is the last reported GPS position of the expedition.",
			"Click, drag, and zoom the map to see data points (currently only animal sightings). For help, information about the expedition, and access to the full API, click on the buttons at the top of the page."
		]

		loadBeacons();

		//DATA LOAD FUNCTIONS
		function loadBeacons() {

			var beaconOptions = {
			    radius: 6,
			    fillColor: "#fff",
			    color: "#333",
			    weight: 5,
			    opacity: 1,
			    fillOpacity: 1,
			};

			function onEachBeacon(feature, layer) {
			    // does this feature have a property named popupContent?
			    if (feature.properties && feature.properties.t_utc) {
			    	var d = new Date(feature.properties.t_utc * 1000);
			        layer.bindPopup("Position beacon from " + d.toString());
			    }
			}


			$.getJSON('/api/timeline?date=20130907&types=beacon&days=100', function(data) {

				//Create the beacon objects
			  L.geoJson(data.features, {
			    filter: function(feature, layer) {
			    	//Filter out 0,0 points
			        return (feature.geometry.coordinates[0] != 0);
			    },
			    pointToLayer: function (feature, latlng) {
			        var marker = L.circleMarker(latlng, beaconOptions);
			        beaconMarkers.push(marker);
			        markers.push(marker);
			        beaconCoords.push([latlng.lng, latlng.lat]);
			        return marker;
			    },
			    onEachFeature:onEachBeacon,
			    style: function(feature) {
			    	//Here we can apply styling to markers depending on properties. Cool.


			    }
				});
			    
			    var lm = beaconMarkers[beaconMarkers.length - 1];
				focusMarker = L.marker(lm.getLatLng()).addTo(map);

				//Create the polygon
				
				var paths = [{
					"type":"Feature",
					"properties":{
						"test":"yes"
					},
					"geometry":{
						"type":"LineString",
						"coordinates":beaconCoords
					}
				}]


				var pathStyle = {
				    fillColor: "#fff",
				    color: "#60C4D7",
				    weight: 3,
				    opacity: 0.2,
				    fillOpacity: 0,
				};
				
				//Add the polygon to the map
				
				var beaconPath = L.geoJson(paths, {
					style:pathStyle
				});

				beaconLayer.addLayer(beaconPath)
				
				
				nextStep();
			});
		}

		function showBeacons() {
			for(var i = 0; i < beaconMarkers.length; i++) {
				//beaconMarkers[i].addTo(map);
				beaconLayer.addLayer(beaconMarkers[i])
			}
		}

		function loadSightings() {

			var sightingOptions = {
			    radius: 2,
			    fillColor: "#78BD52",
			    color: "#FFF",
			    weight: 2,
			    opacity: 0.3,
			    fillOpacity: 0.9,
			};

			function onEachSighting(feature, layer) {
			    // does this feature have a property named popupContent?
			    if (feature.properties && feature.properties.Count) {
			    	var d = new Date(feature.properties.t_utc);
			    	if (feature.properties["Bird Name"].indexOf("quote.") != -1) {
			    		layer.bindPopup("\"" + feature.properties["Bird Name"].split("quote. ")[1] + "\"" + "<br><br>" + d.toString());
			    	} else {
			    		layer.bindPopup(feature.properties.Count + " " + feature.properties["Bird Name"] + "<br><br>" + d.toString());
			    	}
			        
			    }
			}

			var sightingsCluster = new L.MarkerClusterGroup({ disableClusteringAtZoom: 13 });
			var sightingsMarkers = [];
			var quoteMarkers = [];
			var colorMap = [];
			var colorGen = new RColor;


			$.getJSON('/api/timeline?date=20130907&types=sightings&days=100', function(data) {
			  L.geoJson(data.features, {
			    filter: function(feature, layer) {
			    	//Filter out 0,0 points
			        return (feature.geometry.coordinates[0] != 0);
			    },
			    pointToLayer: function (feature, latlng) {
			        var marker = L.circleMarker(latlng, sightingOptions);
			        markers.push(marker);
			        if (feature.properties["Bird Name"].indexOf("quote.") != -1) {
			        	quoteMarkers.push(marker);
			        } else {
			        	sightingsMarkers.push(marker);
			        }
			        
			        return marker;
			    },
			    onEachFeature: onEachSighting,
			    style: function(feature) {
			    	//Here we can apply styling to markers depending on properties. Cool.
			    	var c = Math.sqrt(feature.properties["Count"]);
			    	var so = {radius: 2 + (c * 2)};
			    	if (feature.properties["Bird Name"].indexOf("quote.") != -1) {
			    		so.fillColor = "#FFF";
			    		so.radius = 8;
			    		so.color = "#FF6600";
			    	} else {
			    		var bn = feature.properties["Bird Name"];
			    		if (colorMap[bn] == undefined) {
			    			var c = colorGen.get(true);
			    			so.fillColor = c;
			    			colorMap[bn] = c;
			    		} else {
			    			so.fillColor = colorMap[bn];
			    		}
			    	}
			        return so;
			    }
				})

			  	for (var i = 0; i < quoteMarkers.length; i++) {
			  		commentaryLayer.addLayer(quoteMarkers[i]);
			  	}

			  	for (var i = 0; i < sightingsMarkers.length; i++) {
			  		sightingsCluster.addLayer(sightingsMarkers[i]);
			  	}
			});

			sightingsLayer.addLayer(sightingsCluster);
		}

		function loadPaths() {
			console.log("LOAD PATHS!");
			var pathMap = [];
			var pathCoors = [];
			var pathLats = [];

			$.getJSON('/api/timeline?date=20130907&types=ambit_geo&days=100', function(data) {
			  L.geoJson(data.features, {
			    filter: function(feature, layer) {
			    	//Filter out 0,0 points
			        return (feature.geometry.coordinates[0] != 0);
			    },
			    pointToLayer: function (feature, latlng) {
			    	var name = feature.properties.Person;
			    	if (pathMap[name] == undefined) {
			    		console.log("new path for " + name);
			    		pathMap[name] = [];
			    	}
			        var marker = L.circleMarker(latlng);
			        pathMap[name].push([latlng.lng, latlng.lat]);
			        
			        return marker;
			    },
				})
			  	drawPaths();
			});

			function drawPaths() {

			var names = ["Steve","John","GB"];
			var dashes = ["15,3", "5,5,2", "3,3"];
			var colors = ["#FF3300", "#FF9900", "#FFFF00"]
			
			for (var i = 0; i < names.length; i++) {
				var n = names[i];
				console.log("**" + n);
				console.log(pathMap[n]);
				//Create the path polygons
				//simplify(pathMap[n], 0.8, false);
				
				var paths = [{
					"type":"Feature",
					"properties":{
						"test":"yes"
					},
					"geometry":{
						"type":"LineString",
						"coordinates":pathMap[n]
					}
				}]


				var pathStyle = {
				    fillColor: "#fff",
				    color: colors[i],
				    weight: 2,
				    opacity: 0.4,
				    fillOpacity: 0,
				    smoothFactor:2,
				    dashArray: dashes[i]
				}
				
				//Add the polygon to the map
				var path = L.geoJson(paths, {
					style:pathStyle
				})

				geoLayer.addLayer(path);

				}
			}

		}

		function zoomIn() {
			map.panTo(focusMarker.getLatLng());
			console.log("zoom");
			if (map.getZoom() < 17) map.zoomIn(3);
			if (step < scripts.length) {
				nextStep();
				setTimeout(zoomIn, 8000)
			} else {
				loadSightings();
				loadPaths();
				showBeacons();
				//focusMarker.bindPopup("Last reported position.");
				$("#skip").hide();
			}
			
		}

		function nextStep() {
			if (step < 100) {
				map.panTo(focusMarker.getLatLng());
				focusMarker.bindPopup(scripts[step])
				focusMarker.openPopup();
				step ++;
			}
		}

		function doSkip() {
			step = 100;
			focusMarker.closePopup();
			map.setZoom(17);
			map.panTo(focusMarker.getLatLng());
			focusMarker.bindPopup("Last reported position.");
			$("#skip").hide();
			loadSightings();
			showBeacons();
		}

		//loadBeacons();

		var baseMaps = {
			"Sattelite":satLayer,
			"Flat":flatLayer
		};

		var overlays = {
		    "Position Beacons": beaconLayer,
		    "Wildlife Sightings": sightingsLayer,
		    "GPS Positions": geoLayer,
		    "Quotes & Commentary": commentaryLayer
		};


		L.control.layers(baseMaps, overlays).addTo(map);
		setTimeout(zoomIn, 5000);

		//Buttons
		/*
		onLoad
		*/
		$(function(){
 
			$("#expedition").click(function(event){
				event.preventDefault(); 
				$("#about").show();
				$("#helppanel").hide();
				console.log("expedition");
			});
 
			$("#api").click(function(event){
				event.preventDefault(); 
				window.location = "http://digitalbushman.org/api";
				console.log("API");
			});
 
			$("#help").click(function(event){
				event.preventDefault(); 
				$("#about").hide();
				$("#helppanel").show();
				console.log("help");
			});

			$("#closehelp").click(function(event){
				event.preventDefault(); 
				$("#about").hide();
				$("#helppanel").hide();
				console.log("help");
			});

			$("#closeabout").click(function(event){
				event.preventDefault(); 
				$("#about").hide();
				$("#helppanel").hide();
				console.log("help");
			});

			$("#skip").click(function(event){
				event.preventDefault(); 
				doSkip();
				$("#skip").hide();
				console.log("help");
			});
 
		});

simplifyPath = function( points, tolerance ) {
 
	// helper classes 
	var Vector = function( x, y ) {
		this.x = x;
		this.y = y;
		
	};
	var Line = function( p1, p2 ) {
		this.p1 = p1;
		this.p2 = p2;
		
		this.distanceToPoint = function( point ) {
			// slope
			var m = ( this.p2.y - this.p1.y ) / ( this.p2.x - this.p1.x ),
				// y offset
				b = this.p1.y - ( m * this.p1.x ),
				d = [];
			// distance to the linear equation
			d.push( Math.abs( point.y - ( m * point.x ) - b ) / Math.sqrt( Math.pow( m, 2 ) + 1 ) );
			// distance to p1
			d.push( Math.sqrt( Math.pow( ( point.x - this.p1.x ), 2 ) + Math.pow( ( point.y - this.p1.y ), 2 ) ) );
			// distance to p2
			d.push( Math.sqrt( Math.pow( ( point.x - this.p2.x ), 2 ) + Math.pow( ( point.y - this.p2.y ), 2 ) ) );
			// return the smallest distance
			return d.sort( function( a, b ) {
				return ( a - b ); //causes an array to be sorted numerically and ascending
			} )[0];
		};
	};
	
	var douglasPeucker = function( points, tolerance ) {
		if ( points.length <= 2 ) {
			return [points[0]];
		}
		var returnPoints = [],
			// make line from start to end 
			line = new Line( points[0], points[points.length - 1] ),
			// find the largest distance from intermediate poitns to this line
			maxDistance = 0,
			maxDistanceIndex = 0,
			p;
		for( var i = 1; i <= points.length - 2; i++ ) {
			var distance = line.distanceToPoint( points[ i ] );
			if( distance > maxDistance ) {
				maxDistance = distance;
				maxDistanceIndex = i;
			}
		}
		// check if the max distance is greater than our tollerance allows 
		if ( maxDistance >= tolerance ) {
			p = points[maxDistanceIndex];
			line.distanceToPoint( p, true );
			// include this point in the output 
			returnPoints = returnPoints.concat( douglasPeucker( points.slice( 0, maxDistanceIndex + 1 ), tolerance ) );
			// returnPoints.push( points[maxDistanceIndex] );
			returnPoints = returnPoints.concat( douglasPeucker( points.slice( maxDistanceIndex, points.length ), tolerance ) );
		} else {
			// ditching this point
			p = points[maxDistanceIndex];
			line.distanceToPoint( p, true );
			returnPoints = [points[0]];
		}
		return returnPoints;
	};
	var arr = douglasPeucker( points, tolerance );
	// always have to push the very last point on so it doesn't get left off
	arr.push( points[points.length - 1 ] );
	return arr;
};


					
	</script>
	
</body>
</html>