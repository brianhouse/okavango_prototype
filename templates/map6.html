<!DOCTYPE html>
<html>
  <head>
    <title>Into the Okavango</title>
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta charset="UTF-8">
    
    <link rel="stylesheet" href="../static/css/layout.css" />
    <link rel="stylesheet" href="../static/css/leaflet.css" />
    <link rel="stylesheet" href="../static/js/leaflet.label.css" />
    <link rel="stylesheet" href="../static/js/MarkerCluster.css" />
    <link rel="stylesheet" href="../static/js/MarkerCluster.Default.css" />
    <link rel="stylesheet" href="../static/js/Control.FullScreen.css" />

	<script>
	  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
	  ga('create', 'UA-44288217-1', 'intotheokavango.org');
	  ga('send', 'pageview');
	</script>    
    <script src="../static/js/leaflet.js"></script>
    <script src="../static/js/leaflet.markercluster.js"></script>
    <script src="../static/js/leaflet.label.js"></script>
    <script src="../static/js/rcolor.js"></script>
    <script src="../static/js/simplify.js"></script>
 	<script src="../static/js/Control.FullScreen.js"></script>

    <!--script src='https://api.tiles.mapbox.com/mapbox.js/v2.0.1/mapbox.js'></script-->
	<script language="Javascript" type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>	

    <script>
        $(document).ready(function() {
            console.log("SHUFFLE");
            var $container = $("#col1");
            $container.html(shuffle($container.children().get()));
            var $container = $("#col2");
            $container.html(shuffle($container.children().get()));
            var $container = $("#col3");
            $container.html(shuffle($container.children().get()));
            var $container = $("#col4");
            $container.html(shuffle($container.children().get()));

            $("#skip").click(function(event){
                event.preventDefault(); 
                doSkip();
                $("#skip").hide();
                console.log("SKIP");
            });

            /*
            $('.randcol').each(function() {
                $(this).children().each(function() {
                    $(this).append("<hr/>")
                })
            })
            */

            
        })

        function shuffle(o){
            for(var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
            return o;
        };
    </script>

  </head>
  <body>

	<div id="globalWrapper">
            <div id="headerWrapper">
                <div id="navWrapper" class="transparent">
                    <ul id="pagesNav" class="transparent">
                        <li class="focused">Map</li>
                        <li>About</li>
                        <a href="http://intotheokavango.org/api"><li>API</li></a>
                        <li class="inactive">Data<svg id="loader"></svg></li>

                    </ul>
                    <ul id="mapControls" class="transparent">
                        <!-- <li>See 2013 Expedition</li> -->
                       <!--  <li>+</li>
                        <li>-</li> -->
                        
                    </ul>
                </div>
                <div id="logoWrapper" class="transparent">
                    <div id="logo" class="transparent">
                        <h1 class="transparent"><img src="../static/img/logo.svg" width="100%" alt="Into the Okavango"/></h1>
                        <h4 class="timeDisplay">A Live-data Expedition into the Okavango Delta</h4>
                    </div>
                </div>
            </div>
            <div id="fullPanelWrapper">
                
                <div class="page">
                    <div id="aboutWrapper">
                        <div id="about">
                           <div><h2>About</h2><hr class="subline"/></div>
                            <p>The Okavango Delta is one of the richest wildlife areas on the planet. Starting August 17th, a team of Ba'yei, scientists, artists and engineers will enter the delta to take its pulse.</p>

                                <p>This site displays data which was uploaded daily, via satellite, by the expedition team in the Okavango delta. Data is also available through a <a href="http://intotheokavango.org/api">public API</a>, allowing anyone to re-mix, analyze, or visualize the collected information.</p>
                                <p>Questions? <a href="mailto:okavango@o-c-r.org">okavango@o-c-r.org</a></p>
                            <p><a href="https://en.wikipedia.org/wiki/Okavango_Delta">the Okavango delta</a><span></span><a href="http://en.wikipedia.org/wiki/Bushmen">the BaYei bushmen</a></p>
                        </div>
                        <div id="video">
                            <!-- <iframe width="100%" height="auto" src="http://www.youtube.com/embed/vAiP1iOv23M?autoplay=1&enablejsapi=1" frameborder="0" allowfullscreen></iframe> -->
                            <img src="../static/img/video.jpg" class="poster">
                            <svg width="9%" class="playButton" viewBox="0 0 78 78" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">
                                <defs></defs>
                                <g id="Welcome" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage">
                                    <g id="ABOUT" sketch:type="MSArtboardGroup" transform="translate(-892.000000, -276.000000)" fill-opacity="0.85" fill="#040019">
                                        <path d="M895.009899,276 C893.347578,276 892,277.337425 892,279.009899 L892,350.990101 C892,352.652422 893.337425,354 895.009899,354 L966.990101,354 C968.652422,354 970,352.662575 970,350.990101 L970,279.009899 C970,277.347578 968.662575,276 966.990101,276 L895.009899,276 Z M941.780876,314.989431 L925.709147,325.172764 L925.709147,304.806098 L941.780876,314.989431 Z" id="Rectangle-16" sketch:type="MSShapeGroup"></path>
                                    </g>
                                </g>
                            </svg>
                        </div>
                    </div>

                    <div id="teamWrapper">
                        <div><h2>Team</h2><hr class="subline"/></div>
                        <div class="column" class="randCol" id = "col1">
                            <div class="teammate">
                                <img src="../static/img/sBoyes.png" alt="Steve Boyes' portrait"/>
                                <a href="http://twitter.com/drsteveboyes"><div class="twitter"></div></a>
                                <h3>Steve Boyes</h3>
                                <p class="bio">Steve Boyes did his PhD on the Meyer’s parrot in the Okavango Delta and lived permanently in this wilderness for 7 years. He runs several research project in the Okavango Delta for the Wild Bird Trust and Percy FitzPatrick Institute, and will be the Expedition Leader on the 2014 Okavango Expedition. This year will be his 5th crossing of the Okavango Delta on dug-out canoes or mokoros. All in preparation for the expedition 1,000 miles down the length of the Okavango River next year in support of the designation of new protected areas and a multi-national UNESCO World Heritage Site that includes the entire catchment.</p>
                                <hr/>
                            </div>

                            <div class="teammate">
                                <img src="../static/img/nGelinas.png" alt="Neil Gelinas' portrait"/>
                                <h3>Neil Gelinas</h3>
                                <p class="bio">Neil Gelinas is a Producer, Cameraman and Editor for National Geographic.  For the past 4 years, his focus has been making one-hour-documentary broadcast specials following expeditions lead by Nat Geo Explorers-In-Residence Enric Sala and Mike Fay. Okavango will be his first documentary feature.</p>
                                <hr/>
                            </div>


                            <div class="teammate">
                                <img src="../static/img/gb.png" alt="Gobonamang Kgetho's portrait"/>
                                <h3>Gobonamang Kgetho "GB"</h3>
                                <p class="bio">Lead poler and member of the Seronga Polers Trust. GB has crossed the delta 4 times with Steve and is an exemplary ambassador of the Okavango Delta and baYei community. He has appeared in several TV shows with Steve and his team.</p>
                                <hr/>
                            </div>

                            

                            <div class="teammate">
                                <img src="../static/img/gTrevethick.png" alt="Giles Trevethick' portrait"/>
                                <h3>Giles Trevethick</h3>
                                <p class="bio">An environmental management graduate with a passion for wilderness and adventure. Cycled 2 continents including Africa & South America and about to undertake the 4th trans Okavango Mokoro Expedition with the Wild Bird Trust.</p>
                                <hr/>
                            </div>



                            
                        </div>
                        <div class="column" class="randcol" id="col2">

                            <div class="teammate">
                                <img src="../static/img/tom.png" alt="Goitseone Basiamang's portrait"/>
                                <h3>Goitseone Basiamang "Tom"</h3>
                                <p class="bio">Tom is our strongest poler and has carried us on his shoulders all the way to Maun on 3 important expedition. He is the music man and plays the traditional baYei mouth bow, bringing with him the sound of the African wilderness. His music tells a story of life in the wild. Tom is also an accomplished wilderness guide and storyteller.</p>
                                <hr/>
                            </div>

                            <div class="teammate">
                                <!-- <img src="../static/img/lKgetho.png" alt="Leilamang Kgetho' portrait"/> -->
                                <h3>Leilamang Kgetho</h3>
                                <p class="bio">Son of GB, he too works at the Seronga Polers Trust and has grown up in the Delta, learning from his father. He joins the expedition for the first time this year.</p>
                                <hr/>
                            </div>

                            <div class="teammate">
                                <img src="../static/img/gTreinish.png" alt="Gregg Treinish' portrait"/>
                                <a href="http://www.adventurescience.org/"><div class="website"></div></a>
                                <a href="http://twitter.com/AdventurScience"><div class="twitter"></div></a>
                                <h3>Gregg Treinish</h3>
                                <p class="bio">Gregg Treinish founded the nonprofit Adventurers and Scientists for Conservation in 2011, mobilizing outdoor enthusiasts in collaborative efforts to protect our natural world.<br/><br/>National Geographic named Gregg Adventurer of the Year in 2008, when he and a friend completed a 7,800-mile trek along the spine of the Andes Mountain Range. He was included on the Christian Science Monitor's 30 under 30 list in 2012, and the following year became a National Geographic Emerging Explorer for his work with ASC.</p>
                                <hr/>
                            </div>
                            <div class="teammate">
                                <img src="../static/img/cBoyes.png" alt="Chris Boyes' portrait"/>
                                <h3>Chris Boyes</h3>
                                <p class="bio">"My love and appreciation for places where natural systems function as they have for millions of years drives my passion to understand and protect these areas. Although primarily a marine biologist, I have had the privilege of working in pristine marine and terrestrial ecosystems. I view the Okavango Delta as the epitome of the perfect terrestrial wilderness I seek."</p>
                                <hr/>
                            </div>
 
                        
                        </div>
                        <div class="column" class="randcol" id="col3">
                            <div class="teammate">
                                <img src="../static/img/jHilton.png" alt="John Hilton' portrait"/>
                                <h3>John Hilton</h3>
                                <p class="bio">For the past 4 years John has dedicated his life to spending time in the African wilderness, and sharing his experiences with as many people as possible. In 2010 he and his wife, Liz, travelled around sub-saharan Africa in their Land Cruiser visiting the national parks and wild places of South Africa, Mozambique, Malawi, Kenya, Zambia, Zimbabwe, Botswana and Namibia – an awesome adventure! More recently John has joined Dr Steve Boyes at The Wild Bird Trust as Trustee and Commercial Director.</p>
                                <hr/>
                            </div>

                            <div class="teammate">
                                <img src="../static/img/pHugo.png" alt="Pieter Hugo' portrait"/>
                                <h3>Pieter Hugo</h3>
                                <p class="bio">Pieter Hugo has an MA Degree in English Literature, and has published articles in several different magazines and newspapers. Pieter has worked as a nightclub bouncer, a stage manager, a set-builder, and a pyrotechnics and special effects technician. He currently live in Hogsback, in the Eastern Cape Province of South Africa, where he owns a sawmill and works as a carpenter.</p>
                                <hr/>
                            </div>

                            

                            <div class="teammate">
                                <img src="../static/img/chaps.png" alt="Khunowa Mathare's portrait"/>
                                <h3>Khunowa Mathare "Chaps" </h3>
                                <p class="bio">Delta navigator and human GPS, Chaps has also crossed the Okavango Delta 4 times with Steve and has been able to find our way out of remote locations in the delta many times. He is a rock solid member of the expedition team and an important source of support..</p>
                                <hr/>
                            </div>

                            <div class="teammate">
                                <img src="../static/img/kg.png" alt="Kgalalelo Mpetsang' portrait"/>
                                <h3>Kgalalelo Mpetsang "KG"</h3>
                                <p class="bio">The youngest poler on the expedition. KG joined the 2013 expedition for the first time and proved himself with superb navigational skills as well as his ability to find water when no one else could.</p>
                                <hr/>
                            </div>

                            

                        </div>
                        <div class="column" class="randcol" id="col4">
                            <div class="teammate">
                                <img src="../static/img/jThorpe.png" alt="Jer Thorp' portrait"/>
                                <a href="http://o-c-r.org"><div class="website"></div></a>
                                <a href="http://twitter.com/blprnt"><div class="twitter"></div></a>
                                <h3>Jer Thorp</h3>
                                <p class="bio">Jer Thorp is a software artist, writer, and educator living in Brooklyn. Coming from a background in genetics, his digital art practice explores the many-folded boundaries between science, data, art, and culture. He is a co-founder of The Office for Creative Research & adjunct professor at ITP.</p>
                                <hr/>
                            </div>
                            <div class="teammate">
                                <img src="../static/img/jKydd.png" alt="James Kydd' portrait"/>
                                <a href="http://rangerdiaries.com"><div class="website"></div></a>
                                <a href="http://twitter.com/rangerdiaries"><div class="twitter"></div></a>
                                <h3>James Kydd</h3>
                                <p class="bio">James Kydd is an international safari guide and wildlife photographer. He is the creator of the multiple award winning website Rangerdiaries.com.</p>
                                <hr/>
                            </div>
                            <div class="teammate">
                                <img src="../static/img/sSelbe.png" alt="Shah Selbe' portrait"/>
                                <a href="http://shahselbe.com/"><div class="website"></div></a>
                                <a href="http://twitter.com/shahselbe"><div class="twitter"></div></a>
                                <h3>Shah Selbe</h3>
                                <p class="bio">Shah Selbe is an engineer, conservation technologist, and technology expert working to identify and implement innovative approaches to environmental problems. He works with communities, nonprofits, and developing countries to identify and deploy technologies that could help them with the conservation of their environment. It was this work within ocean conservation, often called “FishNET”, that resulted in National Geographic naming him as one of their 2013 Emerging Explorers. He works to inject low cost technological innovation into how we monitor and protect some of the most pristine parts of this planet.</p>
                                <hr/>
                            </div>
                        </div>
                    </div>

                    <div class="footer">
                        <hr/>
                        <div class="marker"><img src="../static/img/marker.svg"/></div>
                        <hr/>
                    </div>
                </div>


                <div class="page">
                </div>

                <div class="page">
                    <div id="dataWrapper">
                        <div id="data">
                            <div class="column">
                               <div><h2>Data</h2><hr class="subline"/></div>
                                <p></p>
                            </div>
                            <div class="column">
                                <h3>distance</h3>
                                <p class="counter"><span>320km </span><span>total distance</span></p>
                                <p class="counter"><span>average speed</span><span> 3.9km/h</span></p>
                            </div>
                            <div class="column" id="sightings">
                                <h3>sightings</h3>
                                <p></p>
                            </div>
                        </div>
                    </div>

                    <div id="timelineWrapper">
                        <div id="timeline">
                            <svg class="timeline"></svg>
                        </div>
                    </div>

                    <div id="graphWrapper">
                        <div class="graph" id="scale">
                            <svg class="labels"></svg><svg class="graph"></svg>
                        </div>
                        <div id="persons"></div>
                        <h3>heartrate</h3>
                        <div class="graph" id="heartrate">
                            <svg class="labels"></svg><svg class="graph"></svg>
                        </div>
                        <h3>energy consumption</h3>
                        <div class="graph" id="energyConsumption">
                            <svg class="labels"></svg><svg class="graph"></svg>
                        </div>
                        <h3>speed</h3>
                        <div class="graph" id="speed">
                            <svg class="labels"></svg><svg class="graph"></svg>
                        </div>
                    </div>

                    <div class="footer">
                        <hr/>
                        <div class="marker"><img src="../static/img/marker.svg"/></div>
                        <hr/>
                    </div>
                </div>

                
                <div class="page" id="twitterFeed">
                    <div id="twitterWrapper"></div>
                </div>
                
                <svg class="closeButton" width="26px" height="26px" viewBox="0 0 26 26" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">
                    <g id="cross" sketch:type="MSArtboardGroup" fill="#FFFFFF">
                        <rect id="Rectangle-109" sketch:type="MSShapeGroup" transform="translate(13.000000, 13.000000) rotate(45.000000) translate(-13.000000, -13.000000) " x="5" y="11" width="16" height="4"></rect>
                        <rect id="Rectangle-110" sketch:type="MSShapeGroup" transform="translate(13.000000, 13.000000) rotate(135.000000) translate(-13.000000, -13.000000) " x="5" y="11" width="16" height="4"></rect>
                    </g>
                </svg>

            </div>
            <!--Google Maps APIv3 Background-->
			<div id="map_holder">
				<div id="map">
                </div>
                <div id="mapNav">
                    <div id="mapTimeline"><div class="counter"></div><div class="bar"></div><div class="pauseButton">II</div></div>
                    <div id="tweetsButton">tweets</div>
                </div>

                <div id="skip">
                    <a href="#">Skip intro</a>
                </div>

			</div><!-- End Google Maps Background -->
        </div>


	<div id="credits">
        <a href="http://www.o-c-r.org/"><img src="../static/img/ocr.png" alt="The Office for Creative Research logo"/></a>
		<a href="http://www.wildbirdtrust.com/"><img src="../static/img/wbtlogo.png" alt="Wild Bird Trust logo"/></a>
		
	</div>


	<script src="../static/js/d3.min.js"></script>
	<script src="../static/js/main.js"></script>
	<script type="text/javascript">

        //This is the lat/lon point where the map starts by default. In theory this should reset if/when the real data comes in.
        focusLatLon = [-19.08398, 22.37332];
        targetLatLon = [-19.08398, 22.37332];

        var isGraphReady = true;
        var isAnimationPaused = false;
		initLayout();

		// create a map in the "map" div, set the view to a given place and zoom
		var map = L.map('map', {zoomControl:false}).setView(focusLatLon
            , 5);
		var names = ["Steve","Jer","Chris","GB"];
		map.zoomAnimationThreshold = 20;

		//Day skipping - this is not finished functionality to skip days when in 'playback mode'
		var daySkip = false;

		//Extend to add labels on circle markers
		L.CircleMarker.include({

		    bindLabel: function (content, options) {
	
		        if (!this._label || this._label.options !== options) {
		            this._label = new L.Label(options, this);
		        }

		        if (!this.label || this.label.options !== options) {
		            this.label = new L.Label(options, this);
		        }

		        this._map = map;
		        this.label.setContent(content);
		        this._labelNoHide = options && options.noHide;

		        if (!this._showLabelAdded) {
		            if (this._labelNoHide) {
		                this
		                    .on('remove', this.hideLabel, this)
		                    .on('move', this._moveLabel, this);
		                this._showLabel({latlng: this.getLatLng()});
		            } else {
		                this
		                    .on('mouseover', this._showLabel, this)
		                    .on('mousemove', this._moveLabel, this)
		                    .on('mouseout remove', this._hideLabel, this);
		                if (L.Browser.touch) {
		                    this.on('click', this._showLabel, this);
		                }
		            }
		            this._showLabelAdded = true;
		        }

		        return this;
		    },

		    unbindLabel: function () {
		        if (this._label) {
		            this._hideLabel();
		            this._label = null;
		            this._showLabelAdded = false;
		            if (this._labelNoHide) {
		                this
		                    .off('remove', this._hideLabel, this)
		                    .off('move', this._moveLabel, this);
		            } else {
		                this
		                    .off('mouseover', this._showLabel, this)
		                    .off('mousemove', this._moveLabel, this)
		                    .off('mouseout remove', this._hideLabel, this);
		            }
		        }
		        return this;
		    }
		});

	  	

        //*
        //Satellite Layer
		var satLayer = L.tileLayer('http://a.tiles.mapbox.com/v3/brianhouse.map-oxn5wd2a/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors', maxZoom: 17
        }).addTo(map);
        //*/


		// add an OpenStreetMap tile layer
		var flatLayer = L.tileLayer('http://a.tiles.mapbox.com/v3/blprnt.map-vsat7sho/{z}/{x}/{y}.png', {
		    attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors', maxZoom: 17
		})

		//Build some layers
		var beaconLayer = new L.layerGroup().addTo(map);
        var tweetLayer = new L.layerGroup().addTo(map);
        var photoLayer = new L.layerGroup().addTo(map);
		var sightingsLayer = new L.layerGroup().addTo(map);
		var geoLayer = new L.layerGroup().addTo(map);
		var commentaryLayer = new L.layerGroup().addTo(map);

        //NEEDED: hydroLayer

        //Are the various data feeds loaded?
		var sightingsLoaded = false;
		var pathsLoaded = false;
		var beaconsLoaded = false;
        var tweetsLoaded = false;
        var photosLoaded = false;

		var lastPoint;
		var markers = [];
		var beaconMarkers = [];
		var beaconCoords = [];

        var tweetMarkers = [];
        var tweetCoords = [];

        var photoMarkers = [];
        var photoCoords = [];

        var sightingsQueue;
        var tweetsQueue;
        var revealedTweets;
        var revealedTweetTimes;

        var photosQueue;
        var revealedPhotos;
        var revealedPhotoTimes;

		var d = new Date();
		var focusMarker;

		var step = 0;
        var frameCount = 0;
        var lastFrameCount = 0;
        var idleFrameCount = 0;

		var scripts = [
			"This is the Okavango Delta.",
			"Located in Botswana, it is one of the richest wildlife areas on the planet.",
			"On August 17th, a group of BaYei bushmen, artists, scientists, engineers and filmmakers entered the area for an 18-day expedition. The group, led by Dr. Steve Boyes, seeks to explore and survey new parts of the central delta.",
			"On this site, you can examine the data footprint of the expedition, and access all of the data they collect, including wildlife sightings, water quality data, photos, audio, and position and heart rate data for individual expedition members.",
			"Data from the expedition is uploaded in near real-time, as well as at the end of every day.",
			"Click, drag, and zoom the map to see data points (currently animal sightings, comments from the expedition team, and position reports). For help, information about the expedition, and access to the full API, click on the buttons at the top of the page."
		]

		

		//DATA LOAD FUNCTIONS

        //1. Beacons
        //1a. Tweets
        //2. Sightings
        //3. Paths


        //1. Beacons - This one loads beacon data, which are GPS points
		function loadBeacons() {
			var starIcon = L.icon({
			    iconUrl: '../static/img/star2.png',
			    shadowUrl: '../static/img/starShadow2.png',

			    iconSize:     [20,20], // size of the icon
			    shadowSize:   [20,20], // size of the shadow
			    iconAnchor:   [10,10], // point of the icon which will correspond to marker's location
			    shadowAnchor: [10,10],  // the same for the shadow
			    popupAnchor:  [0, -10] // point from which the popup should open relative to the iconAnchor
			});

			var beaconOptions = {
				icon:starIcon,
				iconSize:[20,20]
				/*
			    radius: 6,
			    fillColor: "#fff",
			    color: "#333",
			    weight: 5,
			    opacity: 1,
			    fillOpacity: 1,
			    */
			};
			

			function onEachBeacon(feature, layer) {
			    // does this feature have a property named popupContent?
			    if (feature.properties && feature.properties.t_utc) {
			    	var d = new Date(feature.properties.t_utc * 1000);
			        layer.bindPopup("Position beacon from " + d.toString());
			    }
			}


			$.getJSON('/api/timeline?date=20140817&types=beacon&days=100', function(data) {

				//Create the beacon objects
			  L.geoJson(data.features, {
			    filter: function(feature, layer) {
			    	//Filter out 0,0 points
			        return (feature.geometry.coordinates[0] != 0);
			    },
			    pointToLayer: function (feature, latlng) {
			        var marker = L.marker(latlng, beaconOptions);
			        beaconMarkers.push(marker);
			        markers.push(marker);
			        beaconCoords.push([latlng.lng, latlng.lat]);
			        return marker;
			    },
			    onEachFeature:onEachBeacon,
			    style: function(feature) {
			    	//Here we can apply styling to markers depending on properties. Cool.


			    }
				});
			    
                if (beaconMarkers.length > 0) {
    			    var lm = beaconMarkers[0];
                    map.removeLayer(focusMarker);
                    focusMarker = L.marker(lm.getLatLng()).addTo(map);
                    console.log('origin: ' + lm.getLatLng());

    				//Create the polygon
    				
    				var paths = [{
    					"type":"Feature",
    					"properties":{
    						"test":"yes"
    					},
    					"geometry":{
    						"type":"LineString",
    						"coordinates":beaconCoords
    					}
    				}]


    				var pathStyle = {
    				    fillColor: "#fff",
    				    color: "#60C4D7",
    				    weight: 3,
    				    opacity: 0.2,
    				    fillOpacity: 0,
    				};
    				
    				//Add the polygon to the map
    				
    				var beaconPath = L.geoJson(paths, {
    					style:pathStyle
    				});

    				beaconLayer.addLayer(beaconPath)
                } else {
                    // No focus marker because we haven't started the expedition yet?
                    focusMarker = L.marker(map.getCenter()).addTo(map)
                }
				
                beaconsLoaded = true;
                showBeacons();
				//nextStep();
			});
			
		}

		function showBeacons() {
			for(var i = 0; i < beaconMarkers.length; i++) {
				//beaconMarkers[i].addTo(map);
				beaconLayer.addLayer(beaconMarkers[i])
			}
		}

        //2a. Tweets
        function loadTweets() {

            tweetsQueue = [];
            revealedTweets = [];
            revealedTweetTimes = [];

            var tweetIcon = L.icon({
                iconUrl: '../static/img/quote.png',
                shadowUrl: '../static/img/quoteShadow.png',

                iconSize:     [40,40], // size of the icon
                shadowSize:   [40,40], // size of the shadow
                iconAnchor:   [15,35], // point of the icon which will correspond to marker's location
                shadowAnchor: [15,35],  // the same for the shadow
                popupAnchor:  [10,-40] // point from which the popup should open relative to the iconAnchor
            });

            var tweetOptions = {
                icon:tweetIcon,
                iconSize:[20,20]
                /*
                radius: 6,
                fillColor: "#fff",
                color: "#333",
                weight: 5,
                opacity: 1,
                fillOpacity: 1,
                */
            };
            

            function onEachTweet(feature, layer) {
                // does this feature have a property named popupContent?
                if (feature.properties && feature.properties.t_utc) {
                    var d = new Date(feature.properties.t_utc * 1000);
                    layer.bindPopup(feature.properties.tweet.text);
                }
            }

            console.log("GETTING TWEETS!!!")
            $.getJSON('/api/timeline?date=20140817&types=tweet&days=100', function(data) {

                //Create the beacon objects
                L.geoJson(data.features, {
                    filter: function(feature, layer) {
                        //Filter out 0,0 points
                        return (feature.geometry.coordinates[0] != 0 && feature.properties.tweet.text.substring(0,2).toLowerCase() != 'rt');
                    },
                    pointToLayer: function (feature, latlng) {
                        var marker = L.marker(latlng, tweetOptions);
                        tweetMarkers.push(marker);
                        markers.push(marker);
                        tweetCoords.push([latlng.lng, latlng.lat]);
                        tweetsQueue.push({marker:marker, time:feature.properties.t_utc * 1000});
                        return marker;
                    },
                    onEachFeature:onEachTweet,
                    style: function(feature) {
                        //Here we can apply styling to markers depending on properties. Cool.


                    }
                });
                console.log("GOT TWEETS!!!" + tweetMarkers.length)
                tweetsLoaded = true;
                showTweets();

                initFeed(data);
                
            });
            
        }

        function showTweets() {
            for(var i = 0; i < tweetMarkers.length; i++) {
                //beaconMarkers[i].addTo(map);
                tweetLayer.addLayer(tweetMarkers[i])
            }
        }

        //2b. Photos
        function loadPhotos() {

            photosQueue = [];
            revealedPhotos = [];
            revealedPhotoTimes = [];

            var photoIcon = L.icon({
                iconUrl: '../static/img/picIcon.png',
                shadowUrl: '../static/img/quoteShadow.png',

                iconSize:     [30,30], // size of the icon
                shadowSize:   [30,30], // size of the shadow
                iconAnchor:   [15,35], // point of the icon which will correspond to marker's location
                shadowAnchor: [15,35],  // the same for the shadow
                popupAnchor:  [10,-40] // point from which the popup should open relative to the iconAnchor
            });

            var photoOptions = {
                icon:photoIcon,
                iconSize:[20,20]
                /*
                radius: 6,
                fillColor: "#fff",
                color: "#333",
                weight: 5,
                opacity: 1,
                fillOpacity: 1,
                */
            };
            

            function onEachPhoto(feature, layer) {
                // does this feature have a property named popupContent?
                if (feature.properties && feature.properties.utc_t) {
                    var d = new Date(feature.properties.t_utc * 1000);
                    layer.bindPopup('<img src="' + feature.properties.url + '" width=' + feature.properties.size[0] + ' height=' + feature.properties.size[1] + '>', {maxWidth:1000});
                }
            }

            console.log("GETTING PHOTOS!!!")
            $.getJSON('/api/timeline?date=20140817&types=image&days=18', function(data) {

                //Create the photo objects
                L.geoJson(data.features, {
                    filter: function(feature, layer) {
                        //Filter out 0,0 points
                        return (feature.properties.url.indexOf('james') > -1);
                    },
                    pointToLayer: function (feature, latlng) {

                        var scatterX = ((Math.random() * 2) - 1) * 0.0005;
                        var scatterY = ((Math.random() * 2) - 1) * 0.0005;
                        latlng2 = L.latLng(latlng.lat + scatterY, latlng.lng + scatterX);
                        var marker = L.marker(latlng2, photoOptions);

                        //var marker = L.marker(latlng, photoOptions);
                        photoMarkers.push(marker);
                        markers.push(marker);
                        photoCoords.push([latlng.lng, latlng.lat]);
                        photosQueue.push({marker:marker, time:feature.properties.utc_t * 1000});
                        return marker;
                    },
                    onEachFeature:onEachPhoto,
                    style: function(feature) {
                        //Here we can apply styling to markers depending on properties. Cool.


                    }
                });
                console.log("GOT PHOTOS!!!" + photoMarkers.length)
                photosLoaded = true;
                showPhotos();

                //initFeed(data);
                
            });
            
        }

        function showPhotos() {
            for(var i = 0; i < photoMarkers.length; i++) {
                //beaconMarkers[i].addTo(map);
                photoLayer.addLayer(photoMarkers[i])
            }
        }

		//Set current date (number of days into the expedition)
		var today = new Date();
		currentDay = (today.getMonth() == 7 && today.getDate() > 16) ? (today.getDate() - 17):(17);
		if (currentDay > 18) currentDay == 17;

        console.log("CURRENT DAY!!! ---------------- " + currentDay);

		function makeDate(d) {
            var dd = d;
            var mm = 8;
            if(dd > 31){
                mm = 8 + Math.floor(dd/31);
                dd = dd%31;
            }
            dd = (dd < 10) ? ("0" + dd+1):(dd);
            mm = (mm < 10) ? ("0" + mm):(mm);
            return "2014" + mm + dd;
		}

		sightingsQueue = [];

        //2. - Sightings (wildlife)
		function loadSightings() {

			var quoteIcon = L.icon({
			    iconUrl: '../static/img/quote.png',
			    shadowUrl: '../static/img/quoteShadow.png',

			    iconSize:     [40,40], // size of the icon
			    shadowSize:   [40,40], // size of the shadow
			    iconAnchor:   [15,35], // point of the icon which will correspond to marker's location
			    shadowAnchor: [15,35],  // the same for the shadow
			    popupAnchor:  [10,-40] // point from which the popup should open relative to the iconAnchor
			});

			var sightingOptions = {
			    radius: 2,
			    fillColor: "#FFF",
			    color: "#78BD52",
			    weight: 0,
			    opacity: 0.3,
			    fillOpacity: 0.7,
			};

			function onEachSighting(feature, layer) {
			    // does this feature have a property named popupContent?
			    if (feature.properties && feature.properties.Count) {
			    	var d = new Date(feature.properties.t_utc * 1000);
			    	if (feature.properties["Bird Name"].indexOf("quote.") != -1) {
			    		layer.bindPopup("<h1>\"" + feature.properties["Bird Name"].split("quote. ")[1] + "\"</h1>" + "<br><br>" + d.toString());
			    	} else {
			    		//layer.bindPopup(feature.properties.Count + " " + feature.properties["Bird Name"] + "<br><br>" + d.toString());
			    	}
			        
			    }
			}

			var sightingsCluster = new L.MarkerClusterGroup({ disableClusteringAtZoom: 13 });
			var sightingsMarkers = [];
			var quoteMarkers = [];
			var colorMap = [];
			var colorGen = new RColor;

			function getSightingsDay(d) {
				console.log("GETTING SIGHTINGS:" + sightingDay + ":" + makeDate(d));
				$.getJSON('/api/timeline?date=' + makeDate(d) + '&types=sightings', function(data) {
					//console.log('/api/timeline?date=' + makeDate(d) + '&types=sightings');
					//console.log(data);
				  L.geoJson(data.features, {
				    filter: function(feature, layer) {
				    	//Filter out 0,0 points
				        return (feature.geometry.coordinates[0] != 0);
				    },
				    pointToLayer: function (feature, latlng) {
                        var scatterX = ((Math.random() * 2) - 1) * 0.0005;
                        var scatterY = ((Math.random() * 2) - 1) * 0.0005;
                        latlng2 = L.latLng(latlng.lat + scatterY, latlng.lng + scatterX);
				        var marker = L.circleMarker(latlng2, sightingOptions);

				        markers.push(marker);
				        if (feature.properties["Bird Name"].indexOf("quote.") != -1) {
				        	marker = L.marker(latlng, {icon:quoteIcon})
				        	quoteMarkers.push(marker);
				        } else {
				        	sightingsMarkers.push(marker);
				        	marker.bindLabel(feature.properties.Count + " " + feature.properties["Bird Name"])
				        }
				        sightingsQueue.push({marker:marker, time:feature.properties.t_utc, tries:0});
				        return marker;
				    },
				    onEachFeature: onEachSighting,
				    style: function(feature) {
				    	//Here we can apply styling to markers depending on properties. Cool.
				    	var c = Math.sqrt(feature.properties["Count"]);
				    	var so = {radius: 2 + (c * 2)};
				    	if (feature.properties["Bird Name"].indexOf("quote.") != -1) {
				 
				    	} else {
				    		var bn = feature.properties["Bird Name"];
				    		if (colorMap[bn] == undefined) {
				    			var c = colorGen.get(true);
				    			so.fillColor = c;
				    			colorMap[bn] = c;
				    		} else {
				    			so.fillColor = colorMap[bn];
				    		}
				    	}
				        return so;
				    }
				})

			  	for (var i = 0; i < quoteMarkers.length; i++) {
			  		commentaryLayer.addLayer(quoteMarkers[i]);
			  	}

			  	for (var i = 0; i < sightingsMarkers.length; i++) {
			  		sightingsCluster.addLayer(sightingsMarkers[i]);
			  		
			  	}

                if (sightingDay >= 0) getSightingsDay(sightingDay);
                });
			  	sightingDay ++;

			
			}

			var sightingDay = currentDay;
			getSightingsDay(sightingDay);

			sightingsLayer.addLayer(sightingsCluster);

			sightingsLoaded = true;
		}

        //3. Paths - geo points for each individual team member
		function loadPaths() {
			console.log("LOAD PATHS!");
			pathsLoaded = true;
			
			pathMap = [];
			permPaths = [];
			permGeos = [];
            personMarkers = [];
            personMarkersTarget = [];
			previousPersonMarkersTarget = [];

            pathQueues = [];
			pathRevealed = [];
			for (var i = 0; i < names.length; i++) {
				console.log("MAKE QUEUE FOR " + names[i]);
                pathQueues[names[i]] = [];
				pathRevealed[names[i]] = [];
			}

			function getPathsDay(d) {

				
				var pathCoors = [];
				var pathLats = [];

				var pc = 0;

				console.log("GET PATHS" + makeDate(d));

				$.getJSON('/api/timeline?date=' +  makeDate(d) + '&types=ambit_geo', function(data) {
					console.log('/api/timeline?date=' +  makeDate(d) + '&types=ambit_geo');
				  L.geoJson(data.features, {
				    filter: function(feature, layer) {
				    	//Filter out 0,0 points
				        return (feature.geometry.coordinates[0] != 0);
				    },
				    pointToLayer: function (feature, latlng) {
				    	pc ++;
				    	var name = feature.properties.Person;
				    	if (pathMap[name] == undefined) {
				    		console.log("new path for " + name);
				    		pathMap[name] = [];
				    	}
				        var marker = L.circleMarker(latlng);
				        //pathMap[name].push([latlng.lng, latlng.lat]);
				        pathQueues[name].push({name:name, latLon:[latlng.lat, latlng.lng], time:feature.properties.t_utc});
				        
				        return marker;
				    },
					})
				  	//if (pc > 0) drawPaths(pathMap);

                    if (pathDay >= 0) {
                        getPathsDay(pathDay);
                    } else {
                        //drawPaths();
                    }
				  	pathDay ++;
                    if(updateMapTimelineLoading) updateMapTimelineLoading(data.features[data.features.length-1]);
				});

				
			}

			

			function drawPaths() {

			
    			var dashes = ["15,3", "5,5,2", "3,3","1,1"];
    			var colors = ["#FF3300", "#FF9900", "#FFFF00","#FF6666"]
    			var widths = [30,26,16,12]
    			
    			for (var i = 0; i < names.length; i++) {
    				var n = names[i];
    				//Create the path polygons
    				//simplify(pathMap[n], 0.8, false);

    				//pathMap[n] = smoothIt(pathMap[n]);

    				//Instantiate markers
    				var myIcon = L.divIcon({className: 'person-marker', html: '<p>' + names[i] + '</p>', iconSize: [widths[i], 18]});
    				// you can set .my-div-icon styles in CSS

                    var shiftX = (Math.random() *0.002) - 0.001;
                    var shiftY = (Math.random() *0.002) - 0.001;
                    personMarkers[n] = L.marker([focusLatLon[0] + shiftX, focusLatLon[1] + shiftY], {icon: myIcon}).addTo(map);

                    $('.person-marker').css('width','auto')
    				
    				var paths = [{
    					"type":"Feature",
    					"properties":{
    						"test":"yes"
    					},
    					"geometry":{
    						"type":"LineString",
    						"coordinates":[]
    					}
    				}]

    				permGeos[i] = pathMap[n];


    				var pathStyle = {
    				    fillColor: "#fff",
    				    color: colors[i],
    				    weight: 2,
    				    opacity: 0.4,
    				    fillOpacity: 0,
    				    smoothFactor:2,
    				    // dashArray: dashes[i]
    				}
    				
    				//Add the polygon to the map
    				var path = L.geoJson(paths, {
    					style:pathStyle
    				})

    				geoLayer.addLayer(path);

    				permPaths[n] = path;

                    var ll = permPaths[n].getLayers()[1].getLatLngs();
                    personMarkersTarget[n] = [ll[1].lat,ll[1].lng];
                    previousPersonMarkersTarget[n] = [ll[1].lat,ll[1].lng];

				}

				
			}

			var pathDay = currentDay;
			startAnimation();
			getPathsDay(pathDay);
            drawPaths();
		}

        //******************************
        //START TIME - is set to the beginning of August 17th. I HOPE THIS WORKS!!
        //******************************

		counters = [];
		startTime = 1408269019//     + (currentDay * 60 * 60 * 24);

        console.log("START TIME ---------------- " + startTime);
        console.log("START TIME ---------------- " + new Date(startTime * 1000));

		timeMag = 100;
		timeStep = 0.400;
        timeInterval = [];
        sightingCounter = 0;
		tweetCounter = 0;
        photoCounter = 0;

		for (var i = 0; i < names.length; i++) {
            counters[names[i]] = 1;
			timeInterval[names[i]] = [new Date().getTime(),new Date().getTime()+1];
		}

        var cullMarkers = function(){

            if(frameCount%40 == 0){
                var boundaries = map.getBounds();
                var b = [boundaries.getNorthWest().lat,boundaries.getSouthEast().lat,boundaries.getNorthWest().lng,boundaries.getSouthEast().lng];
                b = [   b[0]+(b[0]-b[1])/2,
                        b[1]+(b[1]-b[0])/2,
                        b[2]+(b[2]-b[3])/2,
                        b[3]+(b[3]-b[2])/2  ];
            }

            if(frameCount%160 == 0){
                var sightings = sightingsLayer.getLayers()[0]._featureGroup.getLayers();
                var l1 = sightings.length;
                var flag;
                for(var i = 0; i<l1; i++){
                    flag = false;
                    var coords = sightings[i].getLatLng();
                    if(coords.lat <= b[0] && coords.lat >= b[1]){
                        if(coords.lng >= b[2] && coords.lng <= b[3]){
                            flag = true;
                        }
                    }
                    d3.select(sightings[i]._container)
                        .style('display',flag?'inline':'none')
                }
            } else if(frameCount%160 == 40){
                var l1 = tweetMarkers.length;
                var flag;
                for(var i=0; i<l1; i++){
                    flag = false;
                    var coords = tweetMarkers[i].getLatLng();
                    if(coords.lat <= b[0] && coords.lat >= b[1]){
                        if(coords.lng >= b[2] && coords.lng <= b[3]){
                            flag = true;
                        }
                    }
                    d3.select(tweetMarkers[i]._icon)
                        .style('display',flag?'inline':'none')
                    d3.select(tweetMarkers[i]._shadow)
                        .style('display',flag?'inline':'none')
                }
            } else if(frameCount%160 == 80){
                var beacons = beaconLayer.getLayers();
                var l1 = beacons.length;
                var flag;
                for(var i=0; i<l1; i++){
                    flag = false;
                    if(beacons[i].getLatLng){
                        var coords = beacons[i].getLatLng();
                        if(coords.lat <= b[0] && coords.lat >= b[1]){
                            if(coords.lng >= b[2] && coords.lng <= b[3]){
                                flag = true;
                            }
                        }
                        d3.select(beacons[i]._icon)
                            .style('display',flag?'inline':'none')
                        d3.select(beacons[i]._shadow)
                            .style('display',flag?'inline':'none')
                    }
                }
            } else if(frameCount%160 == 120){
                var l1 = photoMarkers.length;
                var flag;
                for(var i=0; i<l1; i++){
                    flag = false;
                    var coords = photoMarkers[i].getLatLng();
                    if(coords.lat <= b[0] && coords.lat >= b[1]){
                        if(coords.lng >= b[2] && coords.lng <= b[3]){
                            flag = true;
                        }
                    }
                    d3.select(photoMarkers[i]._icon)
                        .style('display',flag?'inline':'none')
                    d3.select(photoMarkers[i]._shadow)
                        .style('display',flag?'inline':'none')
                }
            }
        }

		function startAnimation() {

            d3.select("#mapTimeline div.pauseButton")
                .on('click',function(){
                    isAnimationPaused = !isAnimationPaused;
                    d3.select(this)
                        .text(isAnimationPaused?'►':'II')
                        .style('font-size',isAnimationPaused?'11px':'18px');
                })
			
			focusLatLon[0] = map.getCenter().lat;
			focusLatLon[1] = map.getCenter().lng;

			targetLatLon[0] = focusLatLon[0];
			targetLatLon[1] = focusLatLon[1];
			
			setInterval(doAnimation,timeStep * 1000);

            var nextFrame = function(){
                frameCount ++;
                if(!isAnimationPaused)posMap();
                cullMarkers();
                requestAnimationFrame(nextFrame);
            }
            nextFrame();

		}

        var posMap = function(){

            var sp = daySkip ? 0.4:0.1;
            var mapValues = function(value, start1, stop1, start2, stop2) {
                return parseFloat(start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1)));
            }
            for (var i = 0; i < names.length; i++) {
                var n = names[i];
                if(personMarkers[n]){
                    var tpos = [0,0];
                    if(counters[n] > 1){
                        var r = Math.max(0,Math.min(1,mapValues(new Date().getTime(),timeInterval[n][0],timeInterval[n][1],0,1)));
                        tpos[0] = mapValues(r,0,1,previousPersonMarkersTarget[n][0],personMarkersTarget[n][0]);
                        tpos[1] = mapValues(r,0,1,previousPersonMarkersTarget[n][1],personMarkersTarget[n][1]);
                    }
                    var personLatLon = personMarkers[n].getLatLng();
                    personLatLon.lat += (tpos[0] - personLatLon.lat) * sp * 2;
                    personLatLon.lng += (tpos[1] - personLatLon.lng) * sp * 2;
                    personMarkers[n].setLatLng(personLatLon);
                    if(i==0) map.setView(personLatLon, map.getZoom(), {pan:{animate:false}});
                }
            }
        }

        //These are the various markers that have been revealed
		revealedMarkers = [];
        revealedMarkerTimes = [];

        //Logic for the time-based animation
		function doAnimation() {

            if(lastFrameCount == frameCount) idleFrameCount ++;
            else idleFrameCount = 0;
            lastFrameCount = frameCount;

            if(isAnimationPaused) return;

            if (sightingsQueue.length > 0 && pathQueues[names[0]].length > 0) {

			startTime += timeStep * timeMag;

			var d = new Date();
			var offset = d.getTimezoneOffset() + 2;
			d.setTime(startTime * 1000 + (offset * 60 * 1000));
            updateMapTimeline(d);

			//Sightings

			while (sightingsQueue[sightingCounter].time < startTime) {
				
				if (!daySkip) {
                    sightingsQueue[sightingCounter].marker.showLabel();
                    revealedMarkers.push(sightingsQueue[sightingCounter])
                    revealedMarkerTimes.push(new Date().getTime());
                }
				sightingCounter ++;
			} 

			var temp = [];	
            var tempt = [];

			for (var i = 0; i < revealedMarkers.length; i++) {
                var now = new Date();
                var nms = now.getTime();
				if (now - revealedMarkerTimes[i] > 3000) {
					revealedMarkers[i].marker.hideLabel();
				} else {
					temp.push(revealedMarkers[i]);
                    tempt.push(revealedMarkerTimes[i]);
				}
			}	
			revealedMarkers = temp;
            revealedMarkerTimes = tempt;


            //Tweets

            if(tweetsQueue.length>0){
                while (tweetsQueue[tweetCounter].time/1000 - 350 < startTime) {
                    if(!daySkip && (!tweetsQueue[tweetCounter+1]||tweetsQueue[tweetCounter+1].time-tweetsQueue[tweetCounter].time>100)){ 
                        // focusTweet(tweetsQueue[tweetCounter]);
                        tweetsQueue[tweetCounter].marker.openPopup();
                        revealedTweets.push(tweetsQueue[tweetCounter])
                        revealedMarkerTimes.push(new Date().getTime());
                    }
                    tweetCounter ++;
                } 
            }

            temp = [];  
            tempt = [];  
            for (var i = 0; i < revealedTweets.length; i++) {
                var now = new Date();
                var nms = now.getTime();
                if (now - revealedTweetTimes[i] > 3000) {
                    revealedTweets[i].marker.closePopup();
                } else {
                    temp.push(revealedTweets[i]);
                    tempt.push(revealedTweetTimes[i]);
                }
            }   
            revealedTweets = temp;     
            revealedTweetTimes = tempt;   

            //Photos

            if(photosQueue.length>0){
                while (photosQueue[photoCounter].time/1000 - 350 < startTime) {
                    if(!daySkip && (!photosQueue[photoCounter+1]||photosQueue[photoCounter+1].time-photosQueue[photoCounter].time>100)){ 
                        // focusTweet(tweetsQueue[tweetCounter]);
                        photosQueue[photoCounter].marker.openPopup();
                        revealedPhotos.push(photosQueue[photoCounter])
                        revealedPhotoTimes.push(new Date().getTime());
                    }
                    photoCounter ++;
                } 
            }

            temp = [];  
            tempt = [];  
            for (var i = 0; i < revealedPhotos.length; i++) {
                var now = new Date();
                var nms = now.getTime();
                if (now - revealedPhotoTimes[i] > 10000) {
                    revealedPhotos[i].marker.closePopup();
                } else {
                    temp.push(revealedPhotos[i]);
                    tempt.push(revealedPhotoTimes[i]);
                }
            }   
            revealedPhotos = temp;     
            revealedPhotoTimes = tempt;     

			//Paths

            var skip = 0;
            var skipCount = 0;

            for (var i = 0; i < names.length; i++) {
                var n = names[i];

                while(startTime > pathQueues[n][counters[n]].time) {
                    var c = counters[n];
                    if (c <= pathQueues[n].length - 1) {
                        
                        var q = pathQueues[n][c];
                        var lq = pathQueues[n][c - 1];

                        if (startTime > q.time) {
                            
                            if(!daySkip){
                                var point = [{
                                    "type":"Feature",
                                    "properties":{
                                        "test":"yes"
                                    },
                                    "geometry":{
                                        "type":"LineString",
                                        "coordinates":[[lq.latLon[1], lq.latLon[0]], [q.latLon[1], q.latLon[0]]]
                                    }
                                }]
                                
                                permPaths[q.name].addData(point);
                                previousPersonMarkersTarget[q.name] = personMarkersTarget[q.name];
                                personMarkersTarget[q.name] = q.latLon;
                                pathRevealed[q.name].push(permPaths[q.name].getLayers()[permPaths[q.name].getLayers().length-1]);
                                if (i == 0) {
                                    targetLatLon[0] = q.latLon[0];
                                    targetLatLon[1] = q.latLon[1];
                                }
                                timeInterval[q.name][0] = new Date().getTime();
                                if(counters[q.name]+1 < pathQueues[q.name].length) timeInterval[q.name][1] = new Date().getTime() + (pathQueues[q.name][counters[q.name]+1].time - pathQueues[q.name][counters[q.name]].time)*1000/(timeMag)
                            }
                            counters[n]++;
                        } 
                    }
                }

                if(startTime < pathQueues[n][counters[n]].time) {
                     var c = counters[n];
                     var q = pathQueues[n][c];
                     var lq = pathQueues[n][c - 1];
                     if (q.time - lq.time > 60 * 30 ) skipCount ++;
                }

                // cull path
                for (var l = 0; l < names.length; l++) {
                    var n = names[l];
                    var boundaries = map.getBounds();
                    var b = [boundaries.getNorthWest().lat,boundaries.getSouthEast().lat,boundaries.getNorthWest().lng,boundaries.getSouthEast().lng];
                    b = [
                            b[0]+(b[0]-b[1])/2,
                            b[1]+(b[1]-b[0])/2,
                            b[2]+(b[2]-b[3])/2,
                            b[3]+(b[3]-b[2])/2
                        ]
                    var len = pathRevealed[n].length;
                    var coords;
                    for(var k=0; k<len; k++){
                        coords = pathRevealed[n][0].getLatLngs();
                        if(coords[1].lat <= b[0] && coords[1].lat >= b[1] && coords[1].lng >= b[2] && coords[1].lng <= b[3]){
                            break;
                        } else {
                            d3.select(pathRevealed[n][0]._container)
                                .style('display','none')
                            pathRevealed[n].shift();
                            len --;
                            k --;
                        }
                    }
                }

            }

            if (skipCount > names.length -2) skip = 50 * 30

			//Night speed up - so that we don't have to watch the animation standing still for 14 hours
			startTime += skip;

            if (daySkip) {
                posMap();
            }
            daySkip = false;

        }

	}

	function smoothIt(pointList) {
		//pointList is a flat list of points [[x,y],[x,y]]
		//Turn it into x,y vectors
		var vectorList = [];
		for(var i = 0; i < pointList.length; i++) {
			vectorList[i] = {x:pointList[i][0], y:pointList[i][1]};
		}
		//Smooth it
		
		console.log("Unsimplified");
		console.log(vectorList);
		vectorList = simplify(vectorList, 0.0008, false);
		console.log("Simplified.");
		console.log(vectorList);
		//Now turn it back into a flat list
		var flatList = [];
		for(var i = 0; i < vectorList.length; i++) {
			flatList[i] = [vectorList[i].x, vectorList[i].y];
		}
		//Spit it out
		return flatList;

	}

    //*********************
    //This is all of the logic for the opening animation (with the text fields)
	function zoomIn() {
		map.panTo(focusMarker.getLatLng());
		console.log("zoom");
		if (map.getZoom() < 17) map.zoomIn(3);
		if (step < scripts.length) {
			nextStep();
			setTimeout(function(){zoomIn(focusMarker)}, 8000)
		} else {
			if (!sightingsLoaded) loadSightings();
			if (!pathsLoaded) loadPaths();
			//if (!beaconsLoaded) showBeacons();
			//focusMarker.bindPopup("Last reported position.");
			$("#skip").hide();
            siteReady();
		}
		
	}

	function nextStep() {
		if (step < 100) {
			map.panTo(focusMarker.getLatLng());
			focusMarker.bindPopup(scripts[step], {maxWidth:400, autoPan:true})
			focusMarker.openPopup();
			step ++;
		}
	}

	function doSkip() {
		step = 100;
		focusMarker.closePopup();
		map.setZoom(17);
		map.panTo(focusMarker.getLatLng());
		focusMarker.bindPopup("Last reported position.");
		$("#skip").hide();
        siteReady();
		if (!sightingsLoaded) loadSightings();
		if (!pathsLoaded) loadPaths();

		clearTimeout(function(){zoomIn(focusMarker)});
	}


    var weAreReady = false;
    function siteReady() {
        if (!weAreReady) {
            loadBeacons();
            loadTweets();
            loadPhotos();
            weAreReady = true;
        }
    }

	//loadBeacons();

    //Populates the menu at top right
	var baseMaps = {
		"Satellite":satLayer,
		"Flat":flatLayer
	};

	var overlays = {
	    "Position Beacons": beaconLayer,
	    "Wildlife Sightings": sightingsLayer,
	    "GPS Positions": geoLayer,
	    "Quotes & Commentary": commentaryLayer
	};

    //Fullscreen controls
	var fullScreen = new L.Control.FullScreen({ position: 'topright' }); 
	map.addControl(fullScreen);

	new L.Control.Zoom({ position: 'topright' }).addTo(map);
    focusMarker = L.marker(map.getCenter()).addTo(map);
	setTimeout(function(){zoomIn(focusMarker)}, 5000);

	var visibleSightings = [];
	var visibleGeos = [];

	//Node selection on change of focus
	map.on('move', function() {
		//console.log("MOVE" + map.getZoom());
	    // construct an empty list to fill with onscreen markers
	    visibleSightings = [];
	    visibleGeos = [];

	    // get the map bounds - the top-left and bottom-right locations
	        bounds = map.getBounds();
	        //console.log(bounds);

	    // for each marker, consider whether it is currently visible by comparing
	    // with the current map bounds
	    /*
	    sightingsLayer.eachLayer(function(marker) {
	        if (bounds.contains(marker.getLatLng())) {
	            visibleSightings.push(marker);
	        }
	    });
		*/

	    /*
	    geoLayer.eachLayer(function(marker) {
	        if (bounds.contains(marker.getLatLng())) {
	            visibleGeos.push(marker);
	        }
	    });
*/

	    //console.log("VISIBLE SIGHTINGS" + visibleSightings.length);
		
	    // display a list of markers.
	    //document.getElementById('onscreen').innerHTML = inBounds.join('\n');
	});


	simplifyPath = function( points, tolerance ) {
	 
		// helper classes 
		var Vector = function( x, y ) {
			this.x = x;
			this.y = y;
			
		};
		var Line = function( p1, p2 ) {
			this.p1 = p1;
			this.p2 = p2;
			
			this.distanceToPoint = function( point ) {
				// slope
				var m = ( this.p2.y - this.p1.y ) / ( this.p2.x - this.p1.x ),
					// y offset
					b = this.p1.y - ( m * this.p1.x ),
					d = [];
				// distance to the linear equation
				d.push( Math.abs( point.y - ( m * point.x ) - b ) / Math.sqrt( Math.pow( m, 2 ) + 1 ) );
				// distance to p1
				d.push( Math.sqrt( Math.pow( ( point.x - this.p1.x ), 2 ) + Math.pow( ( point.y - this.p1.y ), 2 ) ) );
				// distance to p2
				d.push( Math.sqrt( Math.pow( ( point.x - this.p2.x ), 2 ) + Math.pow( ( point.y - this.p2.y ), 2 ) ) );
				// return the smallest distance
				return d.sort( function( a, b ) {
					return ( a - b ); //causes an array to be sorted numerically and ascending
				} )[0];
			};
		};
		
		var douglasPeucker = function( points, tolerance ) {
			if ( points.length <= 2 ) {
				return [points[0]];
			}
			var returnPoints = [],
				// make line from start to end 
				line = new Line( points[0], points[points.length - 1] ),
				// find the largest distance from intermediate poitns to this line
				maxDistance = 0,
				maxDistanceIndex = 0,
				p;
			for( var i = 1; i <= points.length - 2; i++ ) {
				var distance = line.distanceToPoint( points[ i ] );
				if( distance > maxDistance ) {
					maxDistance = distance;
					maxDistanceIndex = i;
				}
			}
			// check if the max distance is greater than our tollerance allows 
			if ( maxDistance >= tolerance ) {
				p = points[maxDistanceIndex];
				line.distanceToPoint( p, true );
				// include this point in the output 
				returnPoints = returnPoints.concat( douglasPeucker( points.slice( 0, maxDistanceIndex + 1 ), tolerance ) );
				// returnPoints.push( points[maxDistanceIndex] );
				returnPoints = returnPoints.concat( douglasPeucker( points.slice( maxDistanceIndex, points.length ), tolerance ) );
			} else {
				// ditching this point
				p = points[maxDistanceIndex];
				line.distanceToPoint( p, true );
				returnPoints = [points[0]];
			}
			return returnPoints;
		};
		var arr = douglasPeucker( points, tolerance );
		// always have to push the very last point on so it doesn't get left off
		arr.push( points[points.length - 1 ] );
		return arr;
	};
					
	</script>
	
</body>
</html>